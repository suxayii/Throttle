cat > /root/net-tune-pro-v3-zh.sh <<'EOF'
#!/usr/bin/env bash
set -euo pipefail

# ===================== 基础路径 =====================
ACTIVE_FILE="/etc/sysctl.d/99-net-tune-pro-v3.conf"            # 网络方案托管文件
BBR_SYSCTL_FILE="/etc/sysctl.d/99-joeyblog.conf"               # BBR/QDISC托管文件
MODULES_CONF="/etc/modules-load.d/joeyblog-qdisc.conf"         # qdisc模块自动加载
BACKUP_DIR="/root/sysctl-backups-v3"
PERM_DIR="/root/sysctl-permanent-baseline-v3"
LAST_APPLY_DIR="${BACKUP_DIR}/last_apply"
HISTORY_DIR="${BACKUP_DIR}/history"
LOG_FILE="/var/log/net-tune-pro-v3.log"

mkdir -p "$BACKUP_DIR" "$PERM_DIR" "$LAST_APPLY_DIR" "$HISTORY_DIR"
touch "$LOG_FILE"

CURRENT_PROFILE=""
ARCH="$(uname -m)"

# ===================== 颜色 =====================
RED='\033[31m'; GREEN='\033[32m'; YELLOW='\033[33m'; BLUE='\033[36m'; BOLD='\033[1m'; NC='\033[0m'
ok(){ echo -e "${GREEN}✅ $*${NC}"; }
warn(){ echo -e "${YELLOW}⚠️  $*${NC}"; }
err(){ echo -e "${RED}❌ $*${NC}"; }
info(){ echo -e "${BLUE}ℹ️  $*${NC}"; }
line(){ echo "------------------------------------------------------------"; }

log(){ echo "[$(date '+%F %T')] $*" >> "$LOG_FILE"; }
pause(){ read -rp "按 Enter 继续..."; }
ts(){ date +%F_%H%M%S; }
cmd_exists(){ command -v "$1" >/dev/null 2>&1; }

need_root(){
  if [[ "${EUID:-$(id -u)}" -ne 0 ]]; then
    err "请使用 root 运行：sudo bash /root/net-tune-pro-v3-zh.sh"
    exit 1
  fi
}

is_debian_like(){
  cmd_exists apt-get
}

# ===================== 依赖检查（尽量不强装） =====================
check_base_deps(){
  local miss=0
  for c in sysctl awk grep sed ip ss find mktemp install; do
    if ! cmd_exists "$c"; then
      err "缺少基础依赖：$c"
      miss=1
    fi
  done
  if (( miss == 1 )); then
    err "基础依赖不完整，请先安装后重试。"
    return 1
  fi
  return 0
}

ensure_bbr_deps_debian(){
  local required=("curl" "wget" "dpkg" "awk" "sed" "sysctl" "jq")
  local need_install=()
  for c in "${required[@]}"; do
    cmd_exists "$c" || need_install+=("$c")
  done

  if [[ ${#need_install[@]} -gt 0 ]]; then
    info "检测到缺少依赖：${need_install[*]}"
    apt-get update -y >/dev/null 2>&1 || true
    apt-get install -y "${need_install[@]}" >/dev/null 2>&1 || {
      err "依赖安装失败：${need_install[*]}"
      return 1
    }
    ok "依赖安装完成"
  fi
}

# ===================== 网络优化方案模板 =====================
common_base() {
cat <<'CONF'
# ===== Generated by net-tune-pro-v3-zh.sh =====
# 通用基础项
net.ipv4.tcp_fastopen = 3
net.ipv4.tcp_mtu_probing = 1
net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_fin_timeout = 20
net.ipv4.ip_local_port_range = 10240 65535
net.core.default_qdisc = fq
net.ipv4.tcp_congestion_control = bbr
net.ipv4.tcp_slow_start_after_idle = 0
CONF
}
profile_balanced(){ cat <<'CONF'
# ---- 方案：平衡版 ----
net.core.netdev_max_backlog = 65536
net.core.somaxconn = 16384
net.ipv4.tcp_max_syn_backlog = 65536
net.core.rmem_default = 262144
net.core.wmem_default = 262144
net.core.rmem_max = 67108864
net.core.wmem_max = 67108864
net.ipv4.tcp_rmem = 4096 87380 33554432
net.ipv4.tcp_wmem = 4096 65536 33554432
net.ipv4.udp_rmem_min = 16384
net.ipv4.udp_wmem_min = 16384
CONF
}
profile_aggressive(){ cat <<'CONF'
# ---- 方案：激进版 ----
net.core.netdev_max_backlog = 250000
net.core.somaxconn = 65535
net.ipv4.tcp_max_syn_backlog = 262144
net.core.rmem_default = 262144
net.core.wmem_default = 262144
net.core.rmem_max = 134217728
net.core.wmem_max = 134217728
net.ipv4.tcp_rmem = 4096 87380 67108864
net.ipv4.tcp_wmem = 4096 65536 67108864
net.ipv4.udp_rmem_min = 16384
net.ipv4.udp_wmem_min = 16384
net.ipv4.tcp_fin_timeout = 15
CONF
}
profile_aggressive_safe(){ cat <<'CONF'
# ---- 方案：激进稳妥版 ----
net.core.netdev_max_backlog = 131072
net.core.somaxconn = 32768
net.ipv4.tcp_max_syn_backlog = 131072
net.core.rmem_default = 262144
net.core.wmem_default = 262144
net.core.rmem_max = 134217728
net.core.wmem_max = 134217728
net.ipv4.tcp_rmem = 4096 87380 67108864
net.ipv4.tcp_wmem = 4096 65536 67108864
net.ipv4.udp_rmem_min = 16384
net.ipv4.udp_wmem_min = 16384
CONF
}
profile_xray_hy2(){ cat <<'CONF'
# ---- 方案：Xray/Hy2 专项 ----
net.core.netdev_max_backlog = 131072
net.core.somaxconn = 32768
net.ipv4.tcp_max_syn_backlog = 131072
net.core.rmem_default = 262144
net.core.wmem_default = 262144
net.core.rmem_max = 134217728
net.core.wmem_max = 134217728
net.ipv4.tcp_rmem = 4096 87380 67108864
net.ipv4.tcp_wmem = 4096 65536 67108864
net.ipv4.udp_rmem_min = 16384
net.ipv4.udp_wmem_min = 16384
CONF
}
profile_low_1c1g(){ cat <<'CONF'
# ---- 方案：低内存保守版 1C/1G ----
net.core.netdev_max_backlog = 8192
net.core.somaxconn = 2048
net.ipv4.tcp_max_syn_backlog = 8192
net.core.rmem_default = 131072
net.core.wmem_default = 131072
net.core.rmem_max = 16777216
net.core.wmem_max = 16777216
net.ipv4.tcp_rmem = 4096 87380 8388608
net.ipv4.tcp_wmem = 4096 65536 8388608
net.ipv4.udp_rmem_min = 8192
net.ipv4.udp_wmem_min = 8192
CONF
}
profile_low_2c2g(){ cat <<'CONF'
# ---- 方案：低内存保守版 2C/2G ----
net.core.netdev_max_backlog = 16384
net.core.somaxconn = 4096
net.ipv4.tcp_max_syn_backlog = 16384
net.core.rmem_default = 262144
net.core.wmem_default = 262144
net.core.rmem_max = 33554432
net.core.wmem_max = 33554432
net.ipv4.tcp_rmem = 4096 87380 16777216
net.ipv4.tcp_wmem = 4096 65536 16777216
net.ipv4.udp_rmem_min = 8192
net.ipv4.udp_wmem_min = 8192
CONF
}
profile_bw_1g(){ cat <<'CONF'
# ---- 方案：高带宽版 1G口 ----
net.core.netdev_max_backlog = 32768
net.core.somaxconn = 16384
net.ipv4.tcp_max_syn_backlog = 65536
net.core.rmem_default = 262144
net.core.wmem_default = 262144
net.core.rmem_max = 67108864
net.core.wmem_max = 67108864
net.ipv4.tcp_rmem = 4096 87380 33554432
net.ipv4.tcp_wmem = 4096 65536 33554432
net.ipv4.udp_rmem_min = 16384
net.ipv4.udp_wmem_min = 16384
CONF
}
profile_bw_10g(){ cat <<'CONF'
# ---- 方案：高带宽版 10G口 ----
net.core.netdev_max_backlog = 131072
net.core.somaxconn = 32768
net.ipv4.tcp_max_syn_backlog = 131072
net.core.rmem_default = 262144
net.core.wmem_default = 262144
net.core.rmem_max = 134217728
net.core.wmem_max = 134217728
net.ipv4.tcp_rmem = 4096 87380 67108864
net.ipv4.tcp_wmem = 4096 65536 67108864
net.ipv4.udp_rmem_min = 16384
net.ipv4.udp_wmem_min = 16384
CONF
}

emit_profile(){
  case "$1" in
    balanced) profile_balanced ;;
    aggressive) profile_aggressive ;;
    aggressive_safe) profile_aggressive_safe ;;
    xray_hy2) profile_xray_hy2 ;;
    low_1c1g) profile_low_1c1g ;;
    low_2c2g) profile_low_2c2g ;;
    bw_1g) profile_bw_1g ;;
    bw_10g) profile_bw_10g ;;
    *) return 1 ;;
  esac
}

# ===================== 校验/检查 =====================
extract_max_from_triplet(){ awk '{print $3}' <<<"$1"; }

validate_profile_semantics(){
  local tmp="$1"
  local rmem_max wmem_max tcp_rmem tcp_wmem tr tw
  rmem_max="$(awk -F= '/^[[:space:]]*net\.core\.rmem_max[[:space:]]*=/{gsub(/[ \t]/,"",$2);print $2}' "$tmp" | tail -n1)"
  wmem_max="$(awk -F= '/^[[:space:]]*net\.core\.wmem_max[[:space:]]*=/{gsub(/[ \t]/,"",$2);print $2}' "$tmp" | tail -n1)"
  tcp_rmem="$(awk -F= '/^[[:space:]]*net\.ipv4\.tcp_rmem[[:space:]]*=/{sub(/^[ \t]+/,"",$2);print $2}' "$tmp" | tail -n1)"
  tcp_wmem="$(awk -F= '/^[[:space:]]*net\.ipv4\.tcp_wmem[[:space:]]*=/{sub(/^[ \t]+/,"",$2);print $2}' "$tmp" | tail -n1)"
  tr="$(extract_max_from_triplet "$tcp_rmem")"
  tw="$(extract_max_from_triplet "$tcp_wmem")"
  [[ -n "$rmem_max" && -n "$tr" ]] && (( rmem_max < tr )) && { err "参数校验失败：rmem_max < tcp_rmem 最大值"; return 1; }
  [[ -n "$wmem_max" && -n "$tw" ]] && (( wmem_max < tw )) && { err "参数校验失败：wmem_max < tcp_wmem 最大值"; return 1; }
  return 0
}

precheck(){
  echo
  echo -e "${BOLD}【预检查阶段】${NC}"
  line
  check_base_deps || return 1

  info "内核版本：$(uname -r || true)"
  if [[ -r /proc/sys/net/ipv4/tcp_available_congestion_control ]] && grep -qw bbr /proc/sys/net/ipv4/tcp_available_congestion_control; then
    ok "内核报告支持 BBR"
  else
    warn "内核未报告 BBR，可继续但 bbr 可能不可用"
  fi

  local nic speed
  nic="$(ip route show default 2>/dev/null | awk '/default/ {print $5; exit}')"
  if [[ -n "${nic:-}" ]]; then
    info "默认网卡：$nic"
    if [[ -r "/sys/class/net/$nic/speed" ]]; then
      speed="$(cat "/sys/class/net/$nic/speed" 2>/dev/null || echo unknown)"
      info "网卡速率（Mbps）：$speed"
    fi
  fi

  [[ -w /etc/sysctl.d ]] || { err "/etc/sysctl.d 不可写"; return 1; }
  sysctl -a >/dev/null 2>&1 || { err "sysctl 读取失败"; return 1; }

  ok "预检查通过"
  return 0
}

conflict_check(){
  echo
  echo -e "${BOLD}【冲突检测】sysctl 重复键${NC}"
  line
  local files=()
  [[ -f /etc/sysctl.conf ]] && files+=(/etc/sysctl.conf)
  while IFS= read -r -d '' f; do files+=("$f"); done < <(find /etc/sysctl.d -maxdepth 1 -type f -name "*.conf" -print0 2>/dev/null | sort -z)
  [[ ${#files[@]} -eq 0 ]] && { warn "未找到配置文件"; return 0; }

  local out
  out="$(
    awk '
      function trim(s){gsub(/^[ \t]+|[ \t]+$/,"",s); return s}
      {
        line=$0; sub(/#.*/,"",line)
        if (line ~ /^[ \t]*$/ || line !~ /=/) next
        split(line,a,"="); key=trim(a[1]); if(key=="") next
        kf=key SUBSEP FILENAME
        if (!(kf in seen)) { seen[kf]=1; cnt[key]++; files[key]=files[key]?files[key] "," FILENAME:FILENAME }
      }
      END{ for(k in cnt) if(cnt[k]>1) print k " => " files[k] }
    ' "${files[@]}" | sort
  )"

  if [[ -z "$out" ]]; then ok "未发现重复键冲突"; else warn "发现重复键："; echo "$out"; fi
  line
}

# ===================== 快照/回滚/永久基线 =====================
save_last_and_history_snapshot(){
  local stamp hdir
  stamp="$(ts)"
  rm -rf "${LAST_APPLY_DIR:?}/"* 2>/dev/null || true
  mkdir -p "$LAST_APPLY_DIR/sysctl.d"
  hdir="${HISTORY_DIR}/${stamp}"
  mkdir -p "$hdir/sysctl.d"

  [[ -f /etc/sysctl.conf ]] && cp -a /etc/sysctl.conf "$LAST_APPLY_DIR/sysctl.conf" || true
  [[ -f /etc/sysctl.conf ]] && cp -a /etc/sysctl.conf "$hdir/sysctl.conf" || true
  cp -a /etc/sysctl.d/*.conf "$LAST_APPLY_DIR/sysctl.d/" 2>/dev/null || true
  cp -a /etc/sysctl.d/*.conf "$hdir/sysctl.d/" 2>/dev/null || true

  [[ -f "$ACTIVE_FILE" ]] && cp -a "$ACTIVE_FILE" "$LAST_APPLY_DIR/managed-active.conf" || true
  [[ -f "$ACTIVE_FILE" ]] && cp -a "$ACTIVE_FILE" "$hdir/managed-active.conf" || true
  [[ -f "$BBR_SYSCTL_FILE" ]] && cp -a "$BBR_SYSCTL_FILE" "$LAST_APPLY_DIR/managed-bbr.conf" || true
  [[ -f "$BBR_SYSCTL_FILE" ]] && cp -a "$BBR_SYSCTL_FILE" "$hdir/managed-bbr.conf" || true
  [[ -f "$MODULES_CONF" ]] && cp -a "$MODULES_CONF" "$LAST_APPLY_DIR/managed-modules.conf" || true
  [[ -f "$MODULES_CONF" ]] && cp -a "$MODULES_CONF" "$hdir/managed-modules.conf" || true

  sysctl -a 2>/dev/null > "$LAST_APPLY_DIR/runtime-sysctl-all.txt" || true
  sysctl -a 2>/dev/null > "$hdir/runtime-sysctl-all.txt" || true
  echo "$hdir"
}

rollback_last_apply_point(){
  [[ -f "$LAST_APPLY_DIR/managed-active.conf" ]] && cp -a "$LAST_APPLY_DIR/managed-active.conf" "$ACTIVE_FILE" || rm -f "$ACTIVE_FILE"
  [[ -f "$LAST_APPLY_DIR/managed-bbr.conf" ]] && cp -a "$LAST_APPLY_DIR/managed-bbr.conf" "$BBR_SYSCTL_FILE" || true
  [[ -f "$LAST_APPLY_DIR/managed-modules.conf" ]] && cp -a "$LAST_APPLY_DIR/managed-modules.conf" "$MODULES_CONF" || true

  if sysctl --system >/tmp/net-tune-v3-rollback.log 2>&1; then
    ok "已回滚到上一次应用点（仅管理文件）"
  else
    err "回滚失败，日志：/tmp/net-tune-v3-rollback.log"
    return 1
  fi
}

save_permanent_baseline(){
  local marker="${PERM_DIR}/BASELINE_LOCK"
  [[ -f "$marker" ]] && { warn "永久初始备份已存在：$PERM_DIR"; return 0; }

  mkdir -p "$PERM_DIR/sysctl.d"
  [[ -f /etc/sysctl.conf ]] && cp -a /etc/sysctl.conf "$PERM_DIR/sysctl.conf" || true
  cp -a /etc/sysctl.d/*.conf "$PERM_DIR/sysctl.d/" 2>/dev/null || true
  [[ -f "$ACTIVE_FILE" ]] && cp -a "$ACTIVE_FILE" "$PERM_DIR/managed-active.conf" || true
  [[ -f "$BBR_SYSCTL_FILE" ]] && cp -a "$BBR_SYSCTL_FILE" "$PERM_DIR/managed-bbr.conf" || true
  [[ -f "$MODULES_CONF" ]] && cp -a "$MODULES_CONF" "$PERM_DIR/managed-modules.conf" || true

  cat > "$marker" <<LOCK
CreatedAt=$(date '+%F %T')
Host=$(hostname)
Kernel=$(uname -r)
Note=Permanent baseline, do not overwrite automatically.
LOCK
  chmod 700 "$PERM_DIR" || true
  chmod 600 "$marker" || true
  ok "永久初始备份创建完成：$PERM_DIR"

  if cmd_exists chattr; then
    read -rp "是否给 BASELINE_LOCK 添加不可变属性（chattr +i）？[y/N]: " yn
    [[ "${yn:-N}" =~ ^[Yy]$ ]] && chattr +i "$marker" 2>/dev/null && ok "已加锁" || true
  fi
}

restore_permanent_baseline(){
  local marker="${PERM_DIR}/BASELINE_LOCK"
  [[ -f "$marker" ]] || { err "未找到永久初始备份"; return 1; }

  save_last_and_history_snapshot >/dev/null || true
  [[ -f "$PERM_DIR/managed-active.conf" ]] && cp -a "$PERM_DIR/managed-active.conf" "$ACTIVE_FILE" || rm -f "$ACTIVE_FILE"
  [[ -f "$PERM_DIR/managed-bbr.conf" ]] && cp -a "$PERM_DIR/managed-bbr.conf" "$BBR_SYSCTL_FILE" || true
  [[ -f "$PERM_DIR/managed-modules.conf" ]] && cp -a "$PERM_DIR/managed-modules.conf" "$MODULES_CONF" || true

  if sysctl --system >/tmp/net-tune-v3-restore-baseline.log 2>&1; then
    ok "已回滚到永久初始配置（管理文件范围）"
  else
    err "回滚失败，日志：/tmp/net-tune-v3-restore-baseline.log"
    return 1
  fi
}

# ===================== 网络方案应用（原子写入） =====================
render_profile_to_tmp(){
  local p="$1" tmp="$2"
  { common_base; emit_profile "$p"; } > "$tmp"
}

apply_profile(){
  local p="$1" tmp hdir
  tmp="$(mktemp /tmp/net-tune-v3.XXXXXX.conf)"
  render_profile_to_tmp "$p" "$tmp" || { rm -f "$tmp"; err "未知方案"; return 1; }
  validate_profile_semantics "$tmp" || { rm -f "$tmp"; return 1; }

  hdir="$(save_last_and_history_snapshot)"
  info "快照已保存：$hdir"

  install -m 0644 "$tmp" "${ACTIVE_FILE}.new"
  mv -f "${ACTIVE_FILE}.new" "$ACTIVE_FILE"
  rm -f "$tmp"

  if ! sysctl -p "$ACTIVE_FILE" >/tmp/net-tune-v3-apply-single.log 2>&1; then
    err "单文件校验失败：/tmp/net-tune-v3-apply-single.log"
    rollback_last_apply_point >/dev/null 2>&1 || true
    return 1
  fi
  if ! sysctl --system >/tmp/net-tune-v3-apply.log 2>&1; then
    err "全量加载失败（可能外部冲突）：/tmp/net-tune-v3-apply.log"
    rollback_last_apply_point >/dev/null 2>&1 || true
    return 1
  fi

  CURRENT_PROFILE="$p"
  ok "方案已应用：$p"
  log "APPLY profile=$p success"
}

# ===================== BBR 功能（中文） =====================
clean_bbr_sysctl_conf(){
  touch "$BBR_SYSCTL_FILE"
  sed -i '/^[[:space:]]*net\.core\.default_qdisc[[:space:]]*=/d' "$BBR_SYSCTL_FILE"
  sed -i '/^[[:space:]]*net\.ipv4\.tcp_congestion_control[[:space:]]*=/d' "$BBR_SYSCTL_FILE"
}

load_qdisc_module(){
  local qdisc_name="$1"
  local module_name="sch_$qdisc_name"
  local current_qdisc
  current_qdisc="$(sysctl -n net.core.default_qdisc 2>/dev/null || echo fq_codel)"

  if sysctl -w net.core.default_qdisc="$qdisc_name" >/dev/null 2>&1; then
    sysctl -w net.core.default_qdisc="$current_qdisc" >/dev/null 2>&1 || true
    return 0
  fi

  if lsmod | grep -q "^${module_name//-/_}"; then
    return 0
  fi

  info "尝试加载模块：$module_name"
  if modprobe "$module_name" 2>/dev/null; then
    ok "模块加载成功：$module_name"
    return 0
  else
    warn "模块加载失败，内核可能不支持：$module_name"
    return 1
  fi
}

bbr_qdisc_apply(){
  local algo="$1" qdisc="$2"
  save_last_and_history_snapshot >/dev/null || true

  load_qdisc_module "$qdisc" || true
  sysctl -w net.core.default_qdisc="$qdisc" >/dev/null 2>&1 || true
  sysctl -w net.ipv4.tcp_congestion_control="$algo" >/dev/null 2>&1 || true

  local new_qdisc new_algo
  new_qdisc="$(sysctl -n net.core.default_qdisc 2>/dev/null || echo unknown)"
  new_algo="$(sysctl -n net.ipv4.tcp_congestion_control 2>/dev/null || echo unknown)"

  if [[ "$new_qdisc" == "$qdisc" && "$new_algo" == "$algo" ]]; then
    ok "已立即生效：队列=$new_qdisc，拥塞控制=$new_algo"
  else
    err "应用失败：期望 $qdisc/$algo，实际 $new_qdisc/$new_algo"
    return 1
  fi

  read -rp "是否永久保存到 $BBR_SYSCTL_FILE ？[y/N]: " save
  if [[ "${save:-N}" =~ ^[Yy]$ ]]; then
    clean_bbr_sysctl_conf
    echo "net.core.default_qdisc=$qdisc" >> "$BBR_SYSCTL_FILE"
    echo "net.ipv4.tcp_congestion_control=$algo" >> "$BBR_SYSCTL_FILE"
    sysctl --system >/tmp/net-tune-v3-bbr-save.log 2>&1 || true

    if [[ "$qdisc" == "fq" || "$qdisc" == "fq_codel" ]]; then
      rm -f "$MODULES_CONF"
    else
      echo "sch_$qdisc" > "$MODULES_CONF"
    fi
    ok "已永久保存"
  else
    warn "未永久保存，重启后可能恢复"
  fi
}

get_installed_joey_kernel(){
  dpkg -l 2>/dev/null | awk '/linux-image/ && /joeyblog/ {print $2}' | sed 's/linux-image-//' | head -n1
}

update_bootloader(){
  info "正在更新引导加载器..."
  if cmd_exists update-grub; then
    if update-grub; then ok "update-grub 成功"; return 0; else err "update-grub 失败"; return 1; fi
  else
    warn "未找到 update-grub。系统可能使用其他引导（如 U-Boot），请按系统文档确认。"
    return 0
  fi
}

install_packages_from_tmp(){
  ls /tmp/linux-*.deb >/dev/null 2>&1 || { err "未找到 /tmp/linux-*.deb"; return 1; }

  local installed
  installed="$(dpkg -l 2>/dev/null | awk '/joeyblog/ {print $2}' | tr '\n' ' ')"
  if [[ -n "$installed" ]]; then
    info "正在卸载旧版内核：$installed"
    apt-get remove --purge -y $installed >/dev/null 2>&1 || true
  fi

  info "正在安装新内核..."
  if dpkg -i /tmp/linux-*.deb && update_bootloader; then
    ok "内核安装完成"
    read -rp "是否立即重启以加载新内核？[y/N]: " rb
    [[ "${rb:-N}" =~ ^[Yy]$ ]] && reboot || warn "请稍后手动重启：sudo reboot"
  else
    err "安装或引导更新失败，请检查系统状态"
    return 1
  fi
}

install_latest_joey_kernel(){
  is_debian_like || { err "该功能仅支持 Debian/Ubuntu（apt-get）"; return 1; }
  ensure_bbr_deps_debian || return 1
  [[ "$ARCH" == "aarch64" || "$ARCH" == "x86_64" ]] || { err "仅支持 aarch64/x86_64，当前：$ARCH"; return 1; }

  local api="https://api.github.com/repos/byJoey/Actions-bbr-v3/releases"
  local data arch_filter latest_tag core_latest installed urls

  info "正在从 GitHub 获取发布信息..."
  data="$(curl -fsSL "$api" || true)"
  [[ -n "$data" ]] || { err "获取发布信息失败"; return 1; }

  arch_filter="x86_64"; [[ "$ARCH" == "aarch64" ]] && arch_filter="arm64"
  latest_tag="$(echo "$data" | jq -r --arg f "$arch_filter" 'map(select(.tag_name|test($f;"i")))|sort_by(.published_at)|.[-1].tag_name')"
  [[ -n "$latest_tag" && "$latest_tag" != "null" ]] || { err "未找到匹配当前架构的版本"; return 1; }

  installed="$(get_installed_joey_kernel)"
  core_latest="${latest_tag#x86_64-}"; core_latest="${core_latest#arm64-}"
  info "最新版本：$latest_tag"
  info "当前已安装：${installed:-未安装}"

  if [[ -n "$installed" && "$installed" == "$core_latest"* ]]; then
    ok "当前已是最新版本"
    return 0
  fi

  urls="$(echo "$data" | jq -r --arg t "$latest_tag" '.[]|select(.tag_name==$t)|.assets[].browser_download_url')"
  rm -f /tmp/linux-*.deb
  while IFS= read -r u; do
    [[ -z "$u" ]] && continue
    info "正在下载：$u"
    wget -q --show-progress "$u" -P /tmp/ || { err "下载失败：$u"; return 1; }
  done <<< "$urls"

  install_packages_from_tmp
}

install_specific_joey_kernel(){
  is_debian_like || { err "该功能仅支持 Debian/Ubuntu"; return 1; }
  ensure_bbr_deps_debian || return 1
  [[ "$ARCH" == "aarch64" || "$ARCH" == "x86_64" ]] || { err "仅支持 aarch64/x86_64"; return 1; }

  local api="https://api.github.com/repos/byJoey/Actions-bbr-v3/releases"
  local data arch_filter selected idx urls
  local -a tags

  data="$(curl -fsSL "$api" || true)"
  [[ -n "$data" ]] || { err "获取发布信息失败"; return 1; }

  arch_filter="x86_64"; [[ "$ARCH" == "aarch64" ]] && arch_filter="arm64"
  mapfile -t tags < <(echo "$data" | jq -r --arg f "$arch_filter" '.[]|select(.tag_name|test($f;"i"))|.tag_name')
  [[ ${#tags[@]} -gt 0 ]] || { err "未找到可用版本"; return 1; }

  echo "可选版本列表："
  for i in "${!tags[@]}"; do
    echo " $((i+1))) ${tags[$i]}"
  done
  read -rp "请输入要安装的版本编号： " idx
  [[ "$idx" =~ ^[0-9]+$ ]] || { err "输入无效"; return 1; }
  (( idx>=1 && idx<=${#tags[@]} )) || { err "编号超出范围"; return 1; }

  selected="${tags[$((idx-1))]}"
  info "已选择版本：$selected"

  urls="$(echo "$data" | jq -r --arg t "$selected" '.[]|select(.tag_name==$t)|.assets[].browser_download_url')"
  rm -f /tmp/linux-*.deb
  while IFS= read -r u; do
    [[ -z "$u" ]] && continue
    info "正在下载：$u"
    wget -q --show-progress "$u" -P /tmp/ || { err "下载失败：$u"; return 1; }
  done <<< "$urls"

  install_packages_from_tmp
}

check_bbr_v3_status(){
  local info_mod version algo qdisc
  info_mod="$(modinfo tcp_bbr 2>/dev/null || true)"
  if [[ -z "$info_mod" ]]; then
    warn "未检测到 tcp_bbr 模块信息（可能未加载或内核不包含）"
  else
    version="$(awk '/^version:/ {print $2}' <<< "$info_mod" | head -n1)"
    [[ -n "$version" ]] && info "tcp_bbr 模块 version：$version" || info "检测到 tcp_bbr 模块（未读到 version 字段）"
  fi

  algo="$(sysctl -n net.ipv4.tcp_congestion_control 2>/dev/null || echo unknown)"
  qdisc="$(sysctl -n net.core.default_qdisc 2>/dev/null || echo unknown)"
  echo "当前拥塞控制：$algo"
  echo "当前队列算法：$qdisc"

  if [[ "$algo" == "bbr" ]]; then ok "BBR 已启用"; else warn "当前未启用 bbr"; fi
}

uninstall_joey_kernel(){
  is_debian_like || { err "该功能仅支持 Debian/Ubuntu"; return 1; }
  local pkgs
  pkgs="$(dpkg -l 2>/dev/null | awk '/joeyblog/ {print $2}' | tr '\n' ' ')"
  if [[ -z "$pkgs" ]]; then
    warn "未找到 joeyblog 内核包"
    return 0
  fi

  info "将卸载以下内核包：$pkgs"
  apt-get remove --purge -y $pkgs || { err "卸载失败"; return 1; }
  update_bootloader || true
  ok "卸载完成，请重启系统"
}

# ===================== 状态/监控 =====================
show_status(){
  echo
  echo -e "${BOLD}【当前状态】${NC}"
  line
  echo "网络方案托管文件：$ACTIVE_FILE"
  echo "BBR托管文件     ：$BBR_SYSCTL_FILE"
  echo "模块配置文件    ：$MODULES_CONF"
  echo "当前会话方案    ：${CURRENT_PROFILE:-unknown}"
  line
  [[ -f "$ACTIVE_FILE" ]] && { echo "[网络方案文件内容]"; cat "$ACTIVE_FILE"; line; }
  [[ -f "$BBR_SYSCTL_FILE" ]] && { echo "[BBR文件内容]"; cat "$BBR_SYSCTL_FILE"; line; }

  sysctl \
    net.core.default_qdisc \
    net.ipv4.tcp_congestion_control \
    net.core.netdev_max_backlog \
    net.core.somaxconn \
    net.ipv4.tcp_max_syn_backlog \
    net.core.rmem_max \
    net.core.wmem_max \
    net.ipv4.tcp_rmem \
    net.ipv4.tcp_wmem 2>/dev/null || true
}

watch_metrics(){
  info "实时监控中（Ctrl+C 返回）"
  sleep 1
  while true; do
    clear
    echo -e "${BOLD}===== $(date '+%F %T') =====${NC}"
    echo "[softnet_stat 丢包列（第2列）前8行]"
    awk '{print NR ": " $2}' /proc/net/softnet_stat | head -n 8
    echo
    echo "[ss -s]"
    ss -s || true
    echo
    nic="$(ip route show default 2>/dev/null | awk '/default/ {print $5; exit}')"
    echo "[默认网卡统计: ${nic:-unknown}]"
    [[ -n "${nic:-}" ]] && ip -s link show "$nic" || ip -s link | sed -n '1,40p'
    echo
    echo "[内存]"
    free -h || true
    sleep 2
  done
}

# ===================== 菜单 =====================
choose_profile_menu(){
  while true; do
    clear
    echo -e "${BOLD}【选择并应用网络优化方案】${NC}"
    line
    echo "1) 平衡版（通用推荐）"
    echo "2) 激进版（高并发/高PPS）"
    echo "3) 激进稳妥版（推荐）"
    echo "4) Xray/Hy2 专项版"
    echo "5) 低内存保守版（1C/1G）"
    echo "6) 低内存保守版（2C/2G）"
    echo "7) 高带宽版（1G口）"
    echo "8) 高带宽版（10G口）"
    echo "0) 返回"
    line
    read -rp "请输入选项 [0-8]: " c

    case "$c" in
      1) p="balanced"; p_name="平衡版（通用推荐）" ;;
      2) p="aggressive"; p_name="激进版（高并发/高PPS）" ;;
      3) p="aggressive_safe"; p_name="激进稳妥版（推荐）" ;;
      4) p="xray_hy2"; p_name="Xray/Hy2 专项版" ;;
      5) p="low_1c1g"; p_name="低内存保守版（1C/1G）" ;;
      6) p="low_2c2g"; p_name="低内存保守版（2C/2G）" ;;
      7) p="bw_1g"; p_name="高带宽版（1G口）" ;;
      8) p="bw_10g"; p_name="高带宽版（10G口）" ;;
      0) return ;;
      *) warn "无效输入"; sleep 1; continue ;;
    esac

    precheck || { pause; continue; }
    conflict_check
    read -rp "确认应用「$p_name」吗？[y/N]: " yn
    if [[ "${yn:-N}" =~ ^[Yy]$ ]]; then
      apply_profile "$p" && ok "已应用：$p_name"
    else
      warn "已取消"
    fi
    pause
    return
  done
}

bbr_menu(){
  while true; do
    clear
    echo -e "${BOLD}【BBR 内核与队列管理】${NC}"
    line
    echo "1) 安装/更新 BBR v3（最新版）"
    echo "2) 安装指定版本 BBR 内核"
    echo "3) 检查 BBR v3 状态"
    echo "4) 启用 BBR + FQ"
    echo "5) 启用 BBR + FQ_CODEL"
    echo "6) 启用 BBR + FQ_PIE"
    echo "7) 启用 BBR + CAKE"
    echo "8) 卸载 joeyblog 内核"
    echo "0) 返回"
    line
    read -rp "请输入选项 [0-8]: " a
    case "$a" in
      1) install_latest_joey_kernel ;;
      2) install_specific_joey_kernel ;;
      3) check_bbr_v3_status ;;
      4) bbr_qdisc_apply "bbr" "fq" ;;
      5) bbr_qdisc_apply "bbr" "fq_codel" ;;
      6) bbr_qdisc_apply "bbr" "fq_pie" ;;
      7) bbr_qdisc_apply "bbr" "cake" ;;
      8) uninstall_joey_kernel ;;
      0) return ;;
      *) warn "无效输入" ;;
    esac
    pause
  done
}

main_menu(){
  while true; do
    clear
    echo -e "${BOLD}${BLUE}"
    echo "╔══════════════════════════════════════════════════════════╗"
    echo "║   Net Tune Pro v3 中文版（网络优化 + BBR 全功能）      ║"
    echo "╚══════════════════════════════════════════════════════════╝"
    echo -e "${NC}"
    echo "1) 预检查阶段"
    echo "2) 冲突检测（sysctl 重复键）"
    echo "3) 应用网络优化方案（原子写入）"
    echo "4) BBR 内核/队列管理（安装/升级/卸载/启用）"
    echo "5) 查看当前状态"
    echo "6) 实时监控"
    echo "7) 回滚到上一次应用点"
    echo "8) 创建永久初始备份（仅首次）"
    echo "9) 回滚到永久初始配置（管理文件范围）"
    echo "10) 查看历史快照列表"
    echo "0) 退出"
    line
    read -rp "请输入选项: " ch
    case "$ch" in
      1) precheck; pause ;;
      2) conflict_check; pause ;;
      3) choose_profile_menu ;;
      4) bbr_menu ;;
      5) show_status; pause ;;
      6) watch_metrics ;;
      7) rollback_last_apply_point; pause ;;
      8) save_permanent_baseline; pause ;;
      9)
        read -rp "确认回滚到永久初始配置？[y/N]: " yn
        [[ "${yn:-N}" =~ ^[Yy]$ ]] && restore_permanent_baseline || warn "已取消"
        pause
        ;;
      10) ls -1 "$HISTORY_DIR" 2>/dev/null | sort || true; pause ;;
      0) ok "已退出"; exit 0 ;;
      *) warn "无效输入"; sleep 1 ;;
    esac
  done
}

need_root
check_base_deps
main_menu
EOF

chmod +x /root/net-tune-pro-v3-zh.sh
bash /root/net-tune-pro-v3-zh.sh
