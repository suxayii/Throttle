cat > /root/net-tune-pro-v2.1.sh <<'EOF'
#!/usr/bin/env bash
set -euo pipefail

# ===================== 基础路径 =====================
ACTIVE_FILE="/etc/sysctl.d/99-net-tune-pro-v2.conf"
BACKUP_DIR="/root/sysctl-backups-v2"
PERM_DIR="/root/sysctl-permanent-baseline"
LAST_APPLY_DIR="${BACKUP_DIR}/last_apply"
HISTORY_DIR="${BACKUP_DIR}/history"
LOG_FILE="/var/log/net-tune-pro-v2.log"

mkdir -p "$BACKUP_DIR" "$PERM_DIR" "$LAST_APPLY_DIR" "$HISTORY_DIR"
touch "$LOG_FILE"

CURRENT_PROFILE=""

# ===================== 颜色 =====================
RED='\033[31m'; GREEN='\033[32m'; YELLOW='\033[33m'; BLUE='\033[36m'; BOLD='\033[1m'; NC='\033[0m'
ok(){ echo -e "${GREEN}✅ $*${NC}"; }
warn(){ echo -e "${YELLOW}⚠️  $*${NC}"; }
err(){ echo -e "${RED}❌ $*${NC}"; }
info(){ echo -e "${BLUE}ℹ️  $*${NC}"; }
line(){ echo "------------------------------------------------------------"; }

log(){ echo "[$(date '+%F %T')] $*" >> "$LOG_FILE"; }
pause(){ read -rp "按 Enter 继续..."; }

# ===================== 通用 =====================
need_root(){
  if [[ "${EUID:-$(id -u)}" -ne 0 ]]; then
    err "请用 root 运行：sudo bash /root/net-tune-pro-v2.1.sh"
    exit 1
  fi
}
cmd_exists(){ command -v "$1" >/dev/null 2>&1; }
ts(){ date +%F_%H%M%S; }

# ===================== 配置模板 =====================
common_base() {
cat <<'CONF'
# ===== Generated by net-tune-pro-v2.1.sh =====
# 通用基础项
net.ipv4.tcp_fastopen = 3
net.ipv4.tcp_mtu_probing = 1
net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_fin_timeout = 20
net.ipv4.ip_local_port_range = 10240 65535
net.core.default_qdisc = fq
net.ipv4.tcp_congestion_control = bbr
net.ipv4.tcp_slow_start_after_idle = 0
CONF
}

profile_balanced() {
cat <<'CONF'
# ---- profile: balanced ----
net.core.netdev_max_backlog = 65536
net.core.somaxconn = 16384
net.ipv4.tcp_max_syn_backlog = 65536
net.core.rmem_default = 262144
net.core.wmem_default = 262144
net.core.rmem_max = 67108864
net.core.wmem_max = 67108864
net.ipv4.tcp_rmem = 4096 87380 33554432
net.ipv4.tcp_wmem = 4096 65536 33554432
net.ipv4.udp_rmem_min = 16384
net.ipv4.udp_wmem_min = 16384
CONF
}

profile_aggressive() {
cat <<'CONF'
# ---- profile: aggressive ----
net.core.netdev_max_backlog = 250000
net.core.somaxconn = 65535
net.ipv4.tcp_max_syn_backlog = 262144
net.core.rmem_default = 262144
net.core.wmem_default = 262144
net.core.rmem_max = 134217728
net.core.wmem_max = 134217728
net.ipv4.tcp_rmem = 4096 87380 67108864
net.ipv4.tcp_wmem = 4096 65536 67108864
net.ipv4.udp_rmem_min = 16384
net.ipv4.udp_wmem_min = 16384
net.ipv4.tcp_fin_timeout = 15
CONF
}

profile_aggressive_safe() {
cat <<'CONF'
# ---- profile: aggressive_safe ----
net.core.netdev_max_backlog = 131072
net.core.somaxconn = 32768
net.ipv4.tcp_max_syn_backlog = 131072
net.core.rmem_default = 262144
net.core.wmem_default = 262144
net.core.rmem_max = 134217728
net.core.wmem_max = 134217728
net.ipv4.tcp_rmem = 4096 87380 67108864
net.ipv4.tcp_wmem = 4096 65536 67108864
net.ipv4.udp_rmem_min = 16384
net.ipv4.udp_wmem_min = 16384
CONF
}

profile_xray_hy2() {
cat <<'CONF'
# ---- profile: xray_hy2 ----
net.core.netdev_max_backlog = 131072
net.core.somaxconn = 32768
net.ipv4.tcp_max_syn_backlog = 131072
net.core.rmem_default = 262144
net.core.wmem_default = 262144
net.core.rmem_max = 134217728
net.core.wmem_max = 134217728
net.ipv4.tcp_rmem = 4096 87380 67108864
net.ipv4.tcp_wmem = 4096 65536 67108864
net.ipv4.udp_rmem_min = 16384
net.ipv4.udp_wmem_min = 16384
CONF
}

profile_low_1c1g() {
cat <<'CONF'
# ---- profile: low_1c1g ----
net.core.netdev_max_backlog = 8192
net.core.somaxconn = 2048
net.ipv4.tcp_max_syn_backlog = 8192
net.core.rmem_default = 131072
net.core.wmem_default = 131072
net.core.rmem_max = 16777216
net.core.wmem_max = 16777216
net.ipv4.tcp_rmem = 4096 87380 8388608
net.ipv4.tcp_wmem = 4096 65536 8388608
net.ipv4.udp_rmem_min = 8192
net.ipv4.udp_wmem_min = 8192
CONF
}

profile_low_2c2g() {
cat <<'CONF'
# ---- profile: low_2c2g ----
net.core.netdev_max_backlog = 16384
net.core.somaxconn = 4096
net.ipv4.tcp_max_syn_backlog = 16384
net.core.rmem_default = 262144
net.core.wmem_default = 262144
net.core.rmem_max = 33554432
net.core.wmem_max = 33554432
net.ipv4.tcp_rmem = 4096 87380 16777216
net.ipv4.tcp_wmem = 4096 65536 16777216
net.ipv4.udp_rmem_min = 8192
net.ipv4.udp_wmem_min = 8192
CONF
}

profile_bw_1g() {
cat <<'CONF'
# ---- profile: bw_1g ----
net.core.netdev_max_backlog = 32768
net.core.somaxconn = 16384
net.ipv4.tcp_max_syn_backlog = 65536
net.core.rmem_default = 262144
net.core.wmem_default = 262144
net.core.rmem_max = 67108864
net.core.wmem_max = 67108864
net.ipv4.tcp_rmem = 4096 87380 33554432
net.ipv4.tcp_wmem = 4096 65536 33554432
net.ipv4.udp_rmem_min = 16384
net.ipv4.udp_wmem_min = 16384
CONF
}

profile_bw_10g() {
cat <<'CONF'
# ---- profile: bw_10g ----
net.core.netdev_max_backlog = 131072
net.core.somaxconn = 32768
net.ipv4.tcp_max_syn_backlog = 131072
net.core.rmem_default = 262144
net.core.wmem_default = 262144
net.core.rmem_max = 134217728
net.core.wmem_max = 134217728
net.ipv4.tcp_rmem = 4096 87380 67108864
net.ipv4.tcp_wmem = 4096 65536 67108864
net.ipv4.udp_rmem_min = 16384
net.ipv4.udp_wmem_min = 16384
CONF
}

emit_profile(){
  case "$1" in
    balanced) profile_balanced ;;
    aggressive) profile_aggressive ;;
    aggressive_safe) profile_aggressive_safe ;;
    xray_hy2) profile_xray_hy2 ;;
    low_1c1g) profile_low_1c1g ;;
    low_2c2g) profile_low_2c2g ;;
    bw_1g) profile_bw_1g ;;
    bw_10g) profile_bw_10g ;;
    *) return 1 ;;
  esac
}

# ===================== 参数关系校验 =====================
extract_max_from_triplet() {
  # input: "a b c" -> c
  awk '{print $3}' <<<"$1"
}

validate_profile_semantics(){
  local tmp="$1"
  local rmem_max wmem_max tcp_rmem tcp_wmem tr tw
  rmem_max="$(awk -F= '/^[[:space:]]*net\.core\.rmem_max[[:space:]]*=/{gsub(/[ \t]/,"",$2);print $2}' "$tmp" | tail -n1)"
  wmem_max="$(awk -F= '/^[[:space:]]*net\.core\.wmem_max[[:space:]]*=/{gsub(/[ \t]/,"",$2);print $2}' "$tmp" | tail -n1)"
  tcp_rmem="$(awk -F= '/^[[:space:]]*net\.ipv4\.tcp_rmem[[:space:]]*=/{sub(/^[ \t]+/,"",$2);print $2}' "$tmp" | tail -n1)"
  tcp_wmem="$(awk -F= '/^[[:space:]]*net\.ipv4\.tcp_wmem[[:space:]]*=/{sub(/^[ \t]+/,"",$2);print $2}' "$tmp" | tail -n1)"

  tr="$(extract_max_from_triplet "$tcp_rmem")"
  tw="$(extract_max_from_triplet "$tcp_wmem")"

  if [[ -n "$rmem_max" && -n "$tr" ]] && (( rmem_max < tr )); then
    err "校验失败: rmem_max($rmem_max) < tcp_rmem_max($tr)"
    return 1
  fi
  if [[ -n "$wmem_max" && -n "$tw" ]] && (( wmem_max < tw )); then
    err "校验失败: wmem_max($wmem_max) < tcp_wmem_max($tw)"
    return 1
  fi
  return 0
}

# ===================== 预检查 =====================
precheck(){
  echo
  echo -e "${BOLD}预检查阶段${NC}"
  line
  local fail=0

  for c in sysctl awk grep sed ip ss find mktemp install; do
    if cmd_exists "$c"; then ok "命令存在: $c"; else err "缺少命令: $c"; fail=1; fi
  done

  info "内核版本: $(uname -r || true)"

  if [[ -r /proc/sys/net/ipv4/tcp_available_congestion_control ]]; then
    if grep -qw bbr /proc/sys/net/ipv4/tcp_available_congestion_control; then
      ok "内核支持 BBR"
    else
      warn "内核未报告 BBR 可用，bbr 可能无法启用"
    fi
  else
    warn "无法检测 tcp_available_congestion_control"
  fi

  local nic speed
  nic="$(ip route show default 2>/dev/null | awk '/default/ {print $5; exit}')"
  if [[ -n "${nic:-}" ]]; then
    info "默认网卡: $nic"
    if [[ -r "/sys/class/net/$nic/speed" ]]; then
      speed="$(cat "/sys/class/net/$nic/speed" 2>/dev/null || echo unknown)"
      info "网卡速率(Mbps): $speed"
    else
      warn "无法读取网卡速率（容器/虚拟网卡常见）"
    fi
  else
    warn "未检测到默认路由网卡"
  fi

  if [[ -w /etc/sysctl.d ]]; then ok "/etc/sysctl.d 可写"; else err "/etc/sysctl.d 不可写"; fail=1; fi
  if sysctl -a >/dev/null 2>&1; then ok "sysctl 可正常读取"; else err "sysctl 读取失败"; fail=1; fi

  line
  if (( fail == 0 )); then ok "预检查通过"; return 0; else err "预检查失败"; return 1; fi
}

# ===================== 冲突检测（去重输出） =====================
conflict_check(){
  echo
  echo -e "${BOLD}冲突检测（sysctl 重复键）${NC}"
  line

  local files=()
  [[ -f /etc/sysctl.conf ]] && files+=(/etc/sysctl.conf)
  while IFS= read -r -d '' f; do files+=("$f"); done < <(find /etc/sysctl.d -maxdepth 1 -type f -name "*.conf" -print0 2>/dev/null | sort -z)

  if [[ ${#files[@]} -eq 0 ]]; then
    warn "未找到可检测配置文件"
    return 0
  fi

  local out
  out="$(
    awk '
      function trim(s){gsub(/^[ \t]+|[ \t]+$/,"",s); return s}
      {
        line=$0
        sub(/#.*/,"",line)
        if (line ~ /^[ \t]*$/) next
        if (line !~ /=/) next
        split(line,a,"=")
        key=trim(a[1]); if(key=="") next
        kf=key SUBSEP FILENAME
        if (!(kf in seen_file)) {
          seen_file[kf]=1
          cnt[key]++
          files[key]=files[key] ? files[key] "," FILENAME : FILENAME
        }
      }
      END{
        for (k in cnt) if (cnt[k]>1) print k " => " files[k]
      }
    ' "${files[@]}" | sort
  )"

  if [[ -z "$out" ]]; then
    ok "未发现重复键冲突"
  else
    warn "发现重复键（后加载文件覆盖先加载文件）:"
    echo "$out"
  fi
  line
}

# ===================== 快照与回滚 =====================
save_last_and_history_snapshot(){
  local stamp
  stamp="$(ts)"

  # 清空并重建 last_apply
  rm -rf "${LAST_APPLY_DIR:?}/"* 2>/dev/null || true
  mkdir -p "$LAST_APPLY_DIR/sysctl.d"

  # 历史目录
  local hdir="${HISTORY_DIR}/${stamp}"
  mkdir -p "$hdir/sysctl.d"

  # 保存当前核心文件（不删除全局）
  [[ -f /etc/sysctl.conf ]] && cp -a /etc/sysctl.conf "$LAST_APPLY_DIR/sysctl.conf" || true
  [[ -f /etc/sysctl.conf ]] && cp -a /etc/sysctl.conf "$hdir/sysctl.conf" || true

  # 保存 sysctl.d 当前快照（只拷贝，不做删除）
  cp -a /etc/sysctl.d/*.conf "$LAST_APPLY_DIR/sysctl.d/" 2>/dev/null || true
  cp -a /etc/sysctl.d/*.conf "$hdir/sysctl.d/" 2>/dev/null || true

  # 保存当前 ACTIVE_FILE 的独立快照
  [[ -f "$ACTIVE_FILE" ]] && cp -a "$ACTIVE_FILE" "$LAST_APPLY_DIR/managed-active.conf" || true
  [[ -f "$ACTIVE_FILE" ]] && cp -a "$ACTIVE_FILE" "$hdir/managed-active.conf" || true

  # 运行时快照
  sysctl -a 2>/dev/null > "$LAST_APPLY_DIR/runtime-sysctl-all.txt" || true
  sysctl -a 2>/dev/null > "$hdir/runtime-sysctl-all.txt" || true

  echo "$hdir"
}

rollback_last_apply_point(){
  # 安全回滚：仅恢复我们管理的 ACTIVE_FILE，不动其他sysctl.d文件
  if [[ -f "$LAST_APPLY_DIR/managed-active.conf" ]]; then
    cp -a "$LAST_APPLY_DIR/managed-active.conf" "$ACTIVE_FILE"
  else
    rm -f "$ACTIVE_FILE"
  fi

  if sysctl --system >/tmp/net-tune-v2-rollback-last.log 2>&1; then
    ok "已回滚到上一次应用点（仅管理文件）"
    log "ROLLBACK last_apply success"
  else
    err "回滚失败，请检查 /tmp/net-tune-v2-rollback-last.log"
    log "ROLLBACK last_apply failed"
    return 1
  fi
}

# ===================== 永久初始备份（可锁定） =====================
save_permanent_baseline(){
  local marker="${PERM_DIR}/BASELINE_LOCK"
  if [[ -f "$marker" ]]; then
    warn "永久初始备份已存在：$PERM_DIR"
    return 0
  fi

  mkdir -p "$PERM_DIR/sysctl.d"

  [[ -f /etc/sysctl.conf ]] && cp -a /etc/sysctl.conf "$PERM_DIR/sysctl.conf" || true
  cp -a /etc/sysctl.d/*.conf "$PERM_DIR/sysctl.d/" 2>/dev/null || true
  [[ -f "$ACTIVE_FILE" ]] && cp -a "$ACTIVE_FILE" "$PERM_DIR/managed-active.conf" || true
  sysctl -a 2>/dev/null > "$PERM_DIR/runtime-sysctl-all.txt" || true

  cat > "$marker" <<LOCK
CreatedAt=$(date '+%F %T')
Host=$(hostname)
Kernel=$(uname -r)
Note=Permanent baseline, do not overwrite automatically.
LOCK

  chmod 700 "$PERM_DIR" || true
  chmod 600 "$marker" || true

  ok "已创建永久初始备份：$PERM_DIR"
  log "BASELINE created"

  if cmd_exists chattr; then
    read -rp "是否对 BASELINE_LOCK 启用不可变(chattr +i)? [y/N]: " yn
    if [[ "${yn:-N}" =~ ^[Yy]$ ]]; then
      if chattr +i "$marker" 2>/dev/null; then
        ok "已启用 immutable: $marker"
      else
        warn "chattr +i 失败（可能文件系统不支持），已跳过"
      fi
    fi
  fi
}

restore_permanent_baseline(){
  local marker="${PERM_DIR}/BASELINE_LOCK"
  if [[ ! -f "$marker" ]]; then
    err "未找到永久初始备份，请先创建"
    return 1
  fi

  save_last_and_history_snapshot >/dev/null || true

  # 仅恢复 managed-active.conf 到 ACTIVE_FILE，不改其他 sysctl.d
  if [[ -f "$PERM_DIR/managed-active.conf" ]]; then
    cp -a "$PERM_DIR/managed-active.conf" "$ACTIVE_FILE"
  else
    rm -f "$ACTIVE_FILE"
  fi

  if sysctl --system >/tmp/net-tune-v2-restore-baseline.log 2>&1; then
    ok "已回滚到永久初始配置（管理文件范围）"
    log "RESTORE baseline success"
  else
    err "回滚失败，请检查 /tmp/net-tune-v2-restore-baseline.log"
    log "RESTORE baseline failed"
    return 1
  fi
}

# ===================== 应用（原子写入 + 双阶段校验） =====================
render_profile_to_tmp(){
  local p="$1" tmp="$2"
  { common_base; emit_profile "$p"; } > "$tmp"
}

apply_profile(){
  local p="$1"
  local tmp hdir
  tmp="$(mktemp /tmp/net-tune-v2.1.XXXXXX.conf)"

  if ! render_profile_to_tmp "$p" "$tmp"; then
    rm -f "$tmp"; err "未知 profile: $p"; return 1
  fi

  if ! validate_profile_semantics "$tmp"; then
    rm -f "$tmp"; return 1
  fi

  # 快照（last + history）
  hdir="$(save_last_and_history_snapshot)"
  info "已保存快照: $hdir"

  # 原子写入
  install -m 0644 "$tmp" "${ACTIVE_FILE}.new"
  mv -f "${ACTIVE_FILE}.new" "$ACTIVE_FILE"
  rm -f "$tmp"

  # 第一步：单文件校验
  if ! sysctl -p "$ACTIVE_FILE" >/tmp/net-tune-v2-apply-single.log 2>&1; then
    err "单文件校验失败: /tmp/net-tune-v2-apply-single.log"
    rollback_last_apply_point >/dev/null 2>&1 || true
    log "APPLY profile=$p failed at single-check"
    return 1
  fi

  # 第二步：全量加载
  if ! sysctl --system >/tmp/net-tune-v2-apply.log 2>&1; then
    err "全量加载失败（可能其他sysctl文件冲突）: /tmp/net-tune-v2-apply.log"
    rollback_last_apply_point >/dev/null 2>&1 || true
    log "APPLY profile=$p failed at system-load"
    return 1
  fi

  CURRENT_PROFILE="$p"
  ok "已应用 profile: $p"
  log "APPLY profile=$p success"
  return 0
}

# ===================== 展示/监控 =====================
show_status(){
  echo
  echo -e "${BOLD}当前状态${NC}"
  line
  echo "Active file: $ACTIVE_FILE"
  echo "Current profile(session): ${CURRENT_PROFILE:-unknown}"
  echo "Backup dir: $BACKUP_DIR"
  echo "History dir: $HISTORY_DIR"
  echo "Permanent baseline: $PERM_DIR"
  line
  if [[ -f "$ACTIVE_FILE" ]]; then cat "$ACTIVE_FILE"; else warn "未发现 active 配置文件"; fi
  line
  sysctl \
    net.core.netdev_max_backlog \
    net.core.somaxconn \
    net.ipv4.tcp_max_syn_backlog \
    net.core.rmem_max \
    net.core.wmem_max \
    net.ipv4.tcp_rmem \
    net.ipv4.tcp_wmem \
    net.ipv4.tcp_fastopen \
    net.ipv4.tcp_mtu_probing \
    net.core.default_qdisc \
    net.ipv4.tcp_congestion_control 2>/dev/null || true
}

list_history_points(){
  echo
  echo -e "${BOLD}历史快照列表${NC}"
  line
  ls -1 "$HISTORY_DIR" 2>/dev/null | sort || true
  line
}

watch_metrics(){
  info "实时监控中（Ctrl+C 返回）"
  sleep 1
  while true; do
    clear
    echo -e "${BOLD}===== $(date '+%F %T') =====${NC}"
    echo "[softnet_stat 丢包列(第2列) 前8行]"
    awk '{print NR ": " $2}' /proc/net/softnet_stat | head -n 8
    echo
    echo "[ss -s]"
    ss -s || true
    echo
    echo "[默认网卡统计]"
    nic="$(ip route show default 2>/dev/null | awk '/default/ {print $5; exit}')"
    if [[ -n "${nic:-}" ]]; then
      ip -s link show "$nic" || true
    else
      ip -s link | sed -n '1,40p' || true
    fi
    echo
    echo "[内存]"
    free -h || true
    sleep 2
  done
}

# ===================== 菜单 =====================
choose_and_apply_profile(){
  while true; do
    clear
    echo -e "${BOLD}选择 profile 并应用${NC}"
    line
    echo "1) balanced"
    echo "2) aggressive"
    echo "3) aggressive_safe"
    echo "4) xray_hy2"
    echo "5) low_1c1g"
    echo "6) low_2c2g"
    echo "7) bw_1g"
    echo "8) bw_10g"
    echo "0) 返回"
    line
    read -rp "输入选项 [0-8]: " c
    case "$c" in
      1) p="balanced" ;;
      2) p="aggressive" ;;
      3) p="aggressive_safe" ;;
      4) p="xray_hy2" ;;
      5) p="low_1c1g" ;;
      6) p="low_2c2g" ;;
      7) p="bw_1g" ;;
      8) p="bw_10g" ;;
      0) return ;;
      *) warn "无效输入"; sleep 1; continue ;;
    esac

    precheck || { pause; continue; }
    conflict_check
    read -rp "确认应用 $p ? [y/N]: " yn
    if [[ "${yn:-N}" =~ ^[Yy]$ ]]; then
      apply_profile "$p" || true
      pause
      return
    else
      warn "已取消"; pause
    fi
  done
}

main_menu(){
  while true; do
    clear
    echo -e "${BOLD}${BLUE}"
    echo "╔══════════════════════════════════════════════════════════╗"
    echo "║  Net Tune Pro v2.1（预检查/冲突检测/原子写入/增强回滚） ║"
    echo "╚══════════════════════════════════════════════════════════╝"
    echo -e "${NC}"
    echo "1) 预检查阶段"
    echo "2) 冲突检测"
    echo "3) 应用 profile（菜单选择）"
    echo "4) 查看状态"
    echo "5) 实时监控"
    echo "6) 回滚到上一次应用点"
    echo "7) 创建永久初始备份（仅首次）"
    echo "8) 回滚到永久初始配置（管理文件范围）"
    echo "9) 查看历史快照列表"
    echo "0) 退出"
    line
    read -rp "请输入 [0-9]: " ch

    case "$ch" in
      1) precheck; pause ;;
      2) conflict_check; pause ;;
      3) choose_and_apply_profile ;;
      4) show_status; pause ;;
      5) watch_metrics ;;
      6) rollback_last_apply_point; pause ;;
      7) save_permanent_baseline; pause ;;
      8)
        read -rp "确认回滚到永久初始配置？[y/N]: " yn
        [[ "${yn:-N}" =~ ^[Yy]$ ]] && restore_permanent_baseline || warn "已取消"
        pause
        ;;
      9) list_history_points; pause ;;
      0) ok "退出"; exit 0 ;;
      *) warn "无效输入"; sleep 1 ;;
    esac
  done
}

need_root
main_menu
EOF

chmod +x /root/net-tune-pro-v2.1.sh
bash /root/net-tune-pro-v2.1.sh
