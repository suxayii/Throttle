#!/bin/bash
# =========================================================
# BBR + 网络优化自动配置脚本 (v6.0 - 增强版)
# - 支持 BBRv3 检测
# - 支持多种队列算法 (fq, fq_codel, fq_pie, cake)
# - 自动模块加载与持久化
# =========================================================
set -Eeuo pipefail

# --- 变量定义 ---
LOG_FILE="/var/log/bbr-optimize.log"
SYSCTL_CONF="/etc/sysctl.conf"
MODULES_CONF="/etc/modules-load.d/bbr_qdisc.conf"
BACKUP_DIR="/etc/sysctl.d/backup"
VALID_QDISC=("fq" "fq_codel" "fq_pie" "cake")
DEFAULT_QDISC="fq"
SKIP_SPEEDTEST=false

# --- 颜色 ---
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
CYAN='\033[0;36m'
PLAIN='\033[0m'

# --- 基础函数 ---
log() {
    echo -e "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

check_root() {
    if [[ $EUID -ne 0 ]]; then
        echo -e "${RED}❌ 错误: 必须使用 Root 权限运行${PLAIN}"
        exit 1
    fi
}

check_dependencies() {
    local missing=()
    for cmd in curl ip sysctl awk sed grep modprobe; do
        if ! command -v "$cmd" &> /dev/null; then
            missing+=("$cmd")
        fi
    done
    
    if [ ${#missing[@]} -ne 0 ]; then
        log "正在安装依赖: ${missing[*]}"
        if command -v apt-get &> /dev/null; then
            apt-get update -qq && apt-get install -y -qq "${missing[@]}"
        elif command -v yum &> /dev/null; then
            yum install -y -q "${missing[@]}"
        else
            echo -e "${RED}❌ 请手动安装依赖: ${missing[*]}${PLAIN}"
            exit 1
        fi
    fi
}

# --- 系统更新 ---
update_system() {
    echo -e "\n${CYAN}--- 系统更新 ---${PLAIN}"
    read -p "是否更新系统软件包? (可能需要较长时间) [y/N]: " choice
    if [[ "$choice" =~ ^[Yy]$ ]]; then
        log "正在更新系统..."
        if command -v apt-get &> /dev/null; then
            apt-get update -y && apt-get upgrade -y
        elif command -v yum &> /dev/null; then
            yum update -y
        elif command -v dnf &> /dev/null; then
            dnf update -y
        else
            log "⚠️ 未知包管理器，跳过系统更新"
            return
        fi
        log "✅ 系统更新完成"
    else
        log "已跳过系统更新"
    fi
}

# --- BBR 版本检测 ---
check_bbr_version() {
    echo -e "\n${CYAN}--- BBR 版本检测 ---${PLAIN}"
    local bbr_info=""
    local bbr_ver=""
    
    if modinfo tcp_bbr &>/dev/null; then
        bbr_info=$(modinfo tcp_bbr)
        bbr_ver=$(echo "$bbr_info" | grep "^version:" | awk '{print $2}')
    fi

    if [[ "$bbr_ver" == "3" ]]; then
        echo -e "当前内核模块: ${GREEN}BBR v3${PLAIN}"
    elif [[ -n "$bbr_ver" ]]; then
        echo -e "当前内核模块: ${GREEN}BBR (标准版) - 版本 $bbr_ver${PLAIN}"
    else
        echo -e "当前内核模块: ${YELLOW}未检测到 BBR 模块 (将在配置后生效)${PLAIN}"
    fi

    # 检查当前运行状态
    local current_cc=$(sysctl -n net.ipv4.tcp_congestion_control 2>/dev/null || echo "none")
    echo -e "当前运行算法: ${GREEN}$current_cc${PLAIN}"
}

# --- 模块管理 ---
load_qdisc_module() {
    local qdisc=$1
    local module="sch_$qdisc"

    # fq 和 fq_codel 通常是内置的，但也尝试加载以防万一
    log "正在检查并加载模块: $module"
    
    if modprobe "$module" &>/dev/null; then
        log "✅ 模块 $module 加载成功"
    else
        # 并不是所有内核都编译了所有模块，失败不一定是错误
        log "⚠️ 模块 $module 加载尝试结束 (可能已内置或不支持)"
    fi

    # 持久化加载配置
    mkdir -p "$(dirname "$MODULES_CONF")"
    if [[ "$qdisc" != "fq" && "$qdisc" != "fq_codel" ]]; then
        if ! grep -q "^$module" "$MODULES_CONF" 2>/dev/null; then
            echo "$module" >> "$MODULES_CONF"
            log "已添加 $module 到自动加载列表"
        fi
    fi
}

# --- Sysctl 配置 ---
apply_optimization() {
    local qdisc=$1
    log "正在应用网络优化配置 (QDisc: $qdisc)..."

    # 1. 备份
    mkdir -p "$BACKUP_DIR"
    cp "$SYSCTL_CONF" "$BACKUP_DIR/sysctl.conf.$(date +%Y%m%d_%H%M%S).bak"

    # 2. 加载模块
    # 确保 BBR 模块加载
    if ! lsmod | grep -q tcp_bbr; then
        modprobe tcp_bbr &>/dev/null || true
        echo "tcp_bbr" > /etc/modules-load.d/bbr.conf
    fi
    load_qdisc_module "$qdisc"

    # 3. 生成配置
    cat > "$SYSCTL_CONF" << EOF
# ==========================================
# BBR Network Optimization
# Generated by bbr.sh at $(date)
# ==========================================

# --- 核心网络参数 ---
net.core.default_qdisc = $qdisc
net.ipv4.tcp_congestion_control = bbr

# --- TCP 缓冲区优化 (基于通常建议值) ---
fs.file-max = 6815744
net.core.rmem_max = 33554432
net.core.wmem_max = 33554432
net.ipv4.tcp_rmem = 4096 87380 33554432
net.ipv4.tcp_wmem = 4096 65536 33554432
net.ipv4.udp_rmem_min = 8192
net.ipv4.udp_wmem_min = 8192

# --- TCP 行为优化 ---
net.ipv4.tcp_notsent_lowat = 16384
net.ipv4.tcp_no_metrics_save = 1
net.ipv4.tcp_ecn = 0
net.ipv4.tcp_frto = 0
net.ipv4.tcp_mtu_probing = 0
net.ipv4.tcp_sack = 1
net.ipv4.tcp_fack = 1
net.ipv4.tcp_window_scaling = 1
net.ipv4.tcp_adv_win_scale = 1
net.ipv4.tcp_moderate_rcvbuf = 1

# --- 连接保持与安全性 ---
net.ipv4.tcp_fin_timeout = 10
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_max_syn_backlog = 8192
net.ipv4.tcp_synack_retries = 2
net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_fastopen = 3

# --- 转发开启 ---
net.ipv4.ip_forward = 1
net.ipv4.conf.all.forwarding = 1
net.ipv4.conf.default.forwarding = 1
net.ipv6.conf.all.forwarding = 1
net.ipv6.conf.default.forwarding = 1
EOF

    # 4. 应用
    if sysctl -p &>/dev/null; then
        echo -e "${GREEN}✅ 优化配置已应用!${PLAIN}"
    else
        echo -e "${RED}⚠️  sysctl 应用失败，请检查配置文件${PLAIN}"
    fi
}

# --- 验证 ---
verify_status() {
    echo -e "\n${CYAN}--- 状态验证 ---${PLAIN}"
    local cc=$(sysctl -n net.ipv4.tcp_congestion_control)
    local qd=$(sysctl -n net.core.default_qdisc)
    
    echo -e "拥塞控制: ${GREEN}$cc${PLAIN} (期望: bbr)"
    echo -e "队列调度: ${GREEN}$qd${PLAIN} (期望: $1)"
    
    if [[ "$cc" == "bbr" && "$qd" == "$1" ]]; then
        echo -e "${GREEN}✨ 优化成功生效!${PLAIN}"
    else
        echo -e "${YELLOW}⚠️  配置似乎未完全生效，建议重启系统。${PLAIN}"
    fi
}

# --- 菜单逻辑 ---
show_menu() {
    clear
    echo "=================================="
    echo "    BBR 网络优化脚本 (v6.0)"
    echo "=================================="
    check_bbr_version
    echo "=================================="
    echo "请选择队列调度算法 (QDisc):"
    echo " 1. fq       (推荐 - 原生性能稳定)"
    echo " 2. fq_codel (通用 - 低延迟)"
    echo " 3. fq_pie   (可选 - 适用于缓冲过大)"
    echo " 4. cake     (高级 - 综合性能极佳，需内核支持)"
    echo " 0. 退出"
    echo "=================================="
    read -p "请输入选项 [1-4]: " choice
    
    case "$choice" in
        1) QDISC="fq" ;;
        2) QDISC="fq_codel" ;;
        3) QDISC="fq_pie" ;;
        4) QDISC="cake" ;;
        0) exit 0 ;;
        *) echo "无效选项，使用默认: fq"; QDISC="fq" ;;
    esac
}

# --- 主流程 ---
main() {
    check_root
    update_system
    check_dependencies
    
    # 参数处理
    if [[ $# -gt 0 ]]; then
        case "$1" in
            fq|fq_codel|fq_pie|cake)
                QDISC="$1"
                ;;
            *)
                echo "用法: $0 [fq|fq_codel|fq_pie|cake]"
                exit 1
                ;;
        esac
    else
        show_menu
    fi
    
    apply_optimization "$QDISC"
    verify_status "$QDISC"
    
    echo -e "\n${YELLOW}提示: 如果选择了 cake/fq_pie 但验证显示为 fq/pfifo_fast，说明当前内核不支持该算法。${PLAIN}"
}

main "$@"
